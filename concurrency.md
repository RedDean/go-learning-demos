### go并发笔记

#### 一. 线程模型

##### 1.1种类

- 内核级线程
- 用户级线程
- 两级型（上面两种都有，也称混合型线程）

 三种模型diff: 用户线程与内核调度实体（KSE, kernel Scheduling Entity）之间的对应关系。

 KSE，即内核级线程，操作系统内核最小调度单元。
 
 ##### 1.2 用户级线程模型
 
 用户线程与KSE是多对一的(N:1)。
 
 **多个用户线程从属于一个用户进程**，多线程操作由用户进程自身的线程库负责(调度在用户层面，因此叫用户级模型)，和os无关。因此CPU不需要在内核态和用户态切换。
 
 OS只知道用户进程(一对一)；os所有的调度基于用户进程；用户进程中所有的线程都只跟**同一个KSE在运行时动态绑定(即N:1)**。
 
 **缺点**: 没办法真正做到并发。假如用户进程内某一子线程被CPU中断（如I/O阻塞，cpu抢占式调度），os会将该用户进程挂起，该进程下的所有线程都被阻塞。
 
 针对上述缺点，有些协程库会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。
 
代表: python

[用户级线程模型](./img/1.png)

##### 1.3 内核级线程模型

用户线程与KSE是一对一的(1:1)。

一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成（调度在内核层面，所以叫内核级）。

**缺点**: 直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。

代表: java、C++

[内核级线程模型](./img/2.png)

##### 1.4 两级型线程模型

用户线程与KSE是一对一的(N:M)。

管理用户线程的用户进程与KSE可以是一对多的，所以用户内的线程可以动态绑定KSE。

**优点**:当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。

用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』。

[两极级线程模型](./img/3.png)

#### 二. go采用的G-P-M模型

OS处理一个进程时，会创建一个栈来保存上下文。这个栈的内存块大小通常是固定的（2MB）。

但go有自己的“线程”，goroutine，即G-P-M中的G。它的内存大小不是固定的，而是动态扩容的，初始时为2KB，可根据任务需要增长。并且GC会周期性回收不再使用的空间，收缩栈。

goroutine完全由Go Scheduler调度。

G并不直接绑定KSE,而是由Scheduler中的Logical Processor(G-P-M中的P)来绑定，一个P绑定一个M。

go中将KSE抽象成数据结构:M。

**M通过P调度执行G。**

Go调度器的数据结构:

- G: 每个goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行。
- P: 逻辑处理器。对G来说，P相当于CPU核，G只有绑定到P(在P的local 
 runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数>= P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。
- M: Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。

**调度算法(work-stealing)**:

- 每个P维护一个G的本地队列。
- G被创建出来或变为可执行状态就将其放入P的可执行队列。
- 当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M先从Global队列取，Global没有，就随机选择另外一个P，从其可执行的G队列中取走一半。

调度时有两种队列，Global和Local(用户类阻塞时有wait)。

当通过go关键字创建一个新的goroutine的时候，它会优先被放入P的本地队列。为了运行goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个goroutine并执行。

**runtime遇到阻塞，运行其他goroutine的情况**:

- blocking syscall (系统类)
- network input   (用户类)
- channel operations   (用户类)
- primitives in the sync package (系统类)

两种类型的阻塞:

- 用户：阻塞的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，而M会跳过该G尝试获取并执行下一个G，如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态；当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为runnable，尝试加入G2所在P的runnext，然后再是P的Local队列和Global队列。
- 系统：当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态，此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。







